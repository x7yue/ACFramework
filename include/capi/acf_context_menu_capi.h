// Copyright (c) 2023 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=b91363197ad3d31db4fe7f74317ad45f7d5e59ff$
//

#ifndef ACF_INCLUDE_CAPI_ACF_CONTEXT_MENU_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_CONTEXT_MENU_CAPI_H_
#pragma once

#include "include/capi/acf_base_capi.h"
#include "include/internal/acf_scoped_refptr.h"
#include "include/internal/acf_string.h"
#include "include/internal/acf_string_list.h"
#include "include/internal/acf_types.h"

#ifdef __cplusplus
extern "C" {
#endif

///
/// Context menu controller
///
typedef struct _acf_context_menu_model_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Returns true (1) if this menu is a submenu.
  ///
  int(ACF_CALLBACK* is_sub_menu)(struct _acf_context_menu_model_t* self);

  ///
  /// Clears the menu. Returns true (1) on success.
  ///
  int(ACF_CALLBACK* clear)(struct _acf_context_menu_model_t* self);

  ///
  /// Returns the number of items in this menu.
  ///
  size_t(ACF_CALLBACK* get_count)(struct _acf_context_menu_model_t* self);

  ///
  /// Insert a separator in the menu at the specified |index|. Returns true (1)
  /// on success.
  ///
  int(ACF_CALLBACK* insert_separator_at)(struct _acf_context_menu_model_t* self,
                                         size_t index);

  ///
  /// Insert an item in the menu at the specified |index|. Returns true (1) on
  /// success.
  ///
  int(ACF_CALLBACK* insert_item_at)(struct _acf_context_menu_model_t* self,
                                    size_t index,
                                    int command_id,
                                    const acf_string_t* label);

  ///
  /// Insert a check item in the menu at the specified |index|. Returns true (1)
  /// on success.
  ///
  int(ACF_CALLBACK* insert_check_item_at)(
      struct _acf_context_menu_model_t* self,
      size_t index,
      int command_id,
      const acf_string_t* label);

  ///
  /// Insert a radio item in the menu at the specified |index|. Only a single
  /// item with the specified |group_id| can be checked at a time. Returns true
  /// (1) on success.
  ///
  int(ACF_CALLBACK* insert_radio_item_at)(
      struct _acf_context_menu_model_t* self,
      size_t index,
      int command_id,
      const acf_string_t* label,
      int group_id);

  ///
  /// Insert a sub-menu in the menu at the specified |index|. The new sub-menu
  /// is returned.
  ///
  struct _acf_context_menu_model_t*(ACF_CALLBACK* insert_sub_menu_at)(
      struct _acf_context_menu_model_t* self,
      size_t index,
      int command_id,
      const acf_string_t* label);

  ///
  /// Removes the item at the specified |index|. Returns true (1) on success.
  ///
  int(ACF_CALLBACK* remove_at)(struct _acf_context_menu_model_t* self,
                               size_t index);

  ///
  /// Returns the command id at the specified |index| or -1 if not found due to
  /// invalid range or the index being a separator.
  ///
  int(ACF_CALLBACK* get_command_id_at)(struct _acf_context_menu_model_t* self,
                                       size_t index);

  ///
  /// Returns the index associated with the specified |command_id| or -1 if not
  /// found due to the command id not existing in the menu.
  ///
  int(ACF_CALLBACK* get_index_of)(struct _acf_context_menu_model_t* self,
                                  int command_id);

  ///
  /// Sets the command id at the specified |index|. Returns true (1) on success.
  ///
  int(ACF_CALLBACK* set_command_id_at)(struct _acf_context_menu_model_t* self,
                                       size_t index,
                                       int command_id);

  ///
  /// Returns the label at the specified |index| or NULL if not found due to
  /// invalid range or the index being a separator.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_label_at)(
      struct _acf_context_menu_model_t* self,
      size_t index);

  ///
  /// Set the label at the specified |index|. Returns true (1) on success.
  ///
  int(ACF_CALLBACK* set_label_at)(struct _acf_context_menu_model_t* self,
                                  size_t index,
                                  const acf_string_t* label);

  ///
  /// Returns true (1) if the specified |index| is visible.
  ///
  int(ACF_CALLBACK* is_visible_at)(struct _acf_context_menu_model_t* self,
                                   size_t index);

  ///
  /// Change the visibility at the specified |index|. Returns true (1) on
  /// success.
  ///
  int(ACF_CALLBACK* set_visible_at)(struct _acf_context_menu_model_t* self,
                                    size_t index,
                                    int visible);

  ///
  /// Returns true (1) if the specified |index| is enabled.
  ///
  int(ACF_CALLBACK* is_enabled_at)(struct _acf_context_menu_model_t* self,
                                   size_t index);

  ///
  /// Change the enabled status at the specified |index|. Returns true (1) on
  /// success.
  ///
  int(ACF_CALLBACK* set_enabled_at)(struct _acf_context_menu_model_t* self,
                                    size_t index,
                                    int enabled);

  ///
  /// Returns the group id at the specified |index| or -1 if invalid.
  ///
  int(ACF_CALLBACK* get_group_id_at)(struct _acf_context_menu_model_t* self,
                                     size_t index);

  ///
  /// Sets the group id at the specified |index|. Returns true (1) on success.
  ///
  int(ACF_CALLBACK* set_group_id_at)(struct _acf_context_menu_model_t* self,
                                     size_t index,
                                     int group_id);

  ///
  /// Returns true (1) if the specified |index| is checked. Only applies to
  /// check and radio items.
  ///
  int(ACF_CALLBACK* is_checked_at)(struct _acf_context_menu_model_t* self,
                                   size_t index);

  ///
  /// Check the specified |index|. Only applies to check and radio items.
  /// Returns true (1) on success.
  ///
  int(ACF_CALLBACK* set_checked_at)(struct _acf_context_menu_model_t* self,
                                    size_t index,
                                    int checked);

  ///
  /// Returns the submenu at the specified |index| or NULL if invalid.
  ///
  struct _acf_context_menu_model_t*(ACF_CALLBACK* get_sub_menu_at)(
      struct _acf_context_menu_model_t* self,
      size_t index);

  ///
  /// Returns the item type at the specified |index|.
  ///
  acf_menu_item_type_t(ACF_CALLBACK* get_type_at)(
      struct _acf_context_menu_model_t* self,
      size_t index);
} acf_context_menu_model_t;

///
/// Provides information about the context menu state. The functions of this
/// structure can only be accessed on browser process the UI thread.
///
typedef struct _acf_context_menu_params_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Returns the X coordinate of the mouse where the context menu was invoked.
  /// Coords are relative to the associated RenderView's origin.
  ///
  int(ACF_CALLBACK* get_xcoord)(struct _acf_context_menu_params_t* self);

  ///
  /// Returns the Y coordinate of the mouse where the context menu was invoked.
  /// Coords are relative to the associated RenderView's origin.
  ///
  int(ACF_CALLBACK* get_ycoord)(struct _acf_context_menu_params_t* self);

  ///
  /// Returns flags representing the type of node that the context menu was
  /// invoked on.
  ///
  acf_context_menu_type_flags_t(ACF_CALLBACK* get_type_flags)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the URL of the link, if any, that encloses the node that the
  /// context menu was invoked on.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_link_url)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the link URL, if any, to be used ONLY for "copy link address". We
  /// don't validate this field in the frontend process.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_unfiltered_link_url)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the source URL, if any, for the element that the context menu was
  /// invoked on. Example of elements with source URLs are img, audio, and
  /// video.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_source_url)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the URL of the top level page that the context menu was invoked
  /// on.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_page_url)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the URL of the subframe that the context menu was invoked on.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_frame_url)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the character encoding of the subframe that the context menu was
  /// invoked on.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_frame_charset)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the type of context node that the context menu was invoked on.
  ///
  acf_context_menu_media_type_t(ACF_CALLBACK* get_media_type)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns flags representing the actions supported by the media element, if
  /// any, that the context menu was invoked on.
  ///
  acf_context_menu_media_state_flags_t(ACF_CALLBACK* get_media_state_flags)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns the text of the selection, if any, that the context menu was
  /// invoked on.
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_selection_text)(
      struct _acf_context_menu_params_t* self);

  ///
  /// Returns true (1) if the context menu was invoked on an editable node.
  ///
  int(ACF_CALLBACK* is_editable)(struct _acf_context_menu_params_t* self);

  ///
  /// Returns flags representing the actions supported by the editable node, if
  /// any, that the context menu was invoked on.
  ///
  acf_context_menu_edit_state_flags_t(ACF_CALLBACK* get_edit_state_flags)(
      struct _acf_context_menu_params_t* self);
} acf_context_menu_params_t;

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_CONTEXT_MENU_CAPI_H_
